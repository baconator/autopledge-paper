##Overview

An ideal pledge call is inserted at exactly the points in a program where static analysis has concluded the keywords it lists are the minimal set necessary for future operation. A conceptual overview of the algorithm which computes these points is given in section 3, however, the handling of both indirect calls, and recursion and looping constructs has not been handled.

Cycles, whether at the function or basic block level, are a concern. A valid analysis must ensure that the possibility of executing a code segment multiple times is taken into account, however, since reasoning about such behaviour would necessitate a form of symbolic execution, the authors propose a method of precision loss instead. Function and basic block summaries are computed such that all code segments in a cycle are considered to make the same set of system calls. This is implemented by representing the calling elements as nodes in a graph, where every node contains a bitvector of possible system calls. Then, for every node, the bitvector of the caller and their own are met and assigned to the caller's node. Since the bitvector and meet operator over bitvectors forms a lattice, application of this algorithm may be shown to a reach a fixpoint in maximally quadratic time in node cardinality.

Without extensive synthesis of guard statements, it is often the case that an indirect call will be made to multiple functions. A simplistic approach was taken: the call site is considered to make the union of system calls made by all possible functions. During pledge call insertion, if any of the possible functions do not have a valid location to insert a pledge (e.g. if the function in question does not make the call at all), it must be inserted following the indirect call to avoid a potential lapse in blacklist coverage.